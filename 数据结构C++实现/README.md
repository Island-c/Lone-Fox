# 数据结构 

## 链表

- 用三个指针实现列表反转时，要注意while的条件，到n为NULL时候就得停止，最后一步反转在循环外部实现即可。 然后要记得把head换成原来的尾结点。
- 单链表成员： 一个node指针
- 双向链表(循环链表，并且双循环)：两个node指针，指向next和prev
  - 插入时，要记得改变前一个节点的next（一般忘不了），和后一个节点的pre（很容易忘）
  - 给定位置要求插入时，注意各种越界以及空指针情况。！

## 栈

- 记得出栈、入栈操作时要递增递减count
- 出栈要先判栈是否为空，入栈判栈是否满（链表栈不需要）
- 析构时，头结点先不动。
- 链表栈成员：一个node指针，一个count（统计成员数量）
- 顺序栈成员：一个数组，一个count（已用大小），一个capacity（总大小）




## 队列

- 数组可实现循环队列。
  - 队空： 队首标志=队尾标志时，表示栈空，即红绿两个标志在图中重叠时为栈空。       .           begin==end
  - 队满 : 队尾+1 = 队首时，表示栈空。图三最下面的队列即为一个满队列。尽管还有一个空位，我们不存储元素。 end + 1 % capacity == begin
  - size = (end - begin + capacity) % capacity
  - 出队列： begin = (begin + 1) % capacity
  - 入队列： end = (end+1) %capacity
  - 成员：一个数组，begin , end , capacity
- 链队列
  - 成员：两个node指针，分别指向队首队尾。 一个count，计数。
  - 记得count递增递减即可。

## 树 

- 概念： 斜树、满二叉树、完全二叉树、二叉查找树

  - 二叉查找树
    - 若它的左子树不为空，那么左子树上所有节点的key都小于根节点的key
    - 若它的右子树不为空，那么右子树上所有节点的key都大于根节点的key
    - 它的左右子树也分别为二叉排序树
  - 二叉树性质
    - 第i层最多 2^(i-1)个节点
    - 深度为k，最多 2^k -1 个节点

### 二叉排列树( BST )

#### 插入
> 新元素与节点的key比较，小于，则查找左子树，大于则查找右子树。

  - 永远都只在叶子上进行插入。

      - 1.找到合适的插入位置，确定父节点。 2.判断父节点是根节点还是叶子 3.根据key的大小比较，确定插入位置。 4. 给插入的节点的parent指针赋值。
- 注意找到插入位置并插入后，要建立的是一个**双向的关系** ，要记得给新插入的节点的parent赋值。
#### 遍历

- 注意中序遍历时，右子树也要先先进到最左的节点再遍历。！



- 二叉排列树中序遍历正好可以得到一个非递减序列


 #### 前驱 
 > (基于中序遍历， 左父右)  

- 它有左子树，则左子树的最右子树节点 为其前驱节点
- 它没有左子树（下面两种情况可以一起判断）
  - 它本身为右子树，则其父节点为其前驱节点
  - 它本身为左子树，则它的前驱节点为“第一个拥有右子树的父节点”
  - ** 如果它本身就是整棵树的第一个元素，则会遍历到根节点的父节点，然后返回nullptr ** 

#### 后继

- 它有右子树，则后继节点是它右子树的最左节点
- 它没有右子树
  - 他是左子树，则父节点为后继节点
  - 他是右子树，则后继节点是“第一个拥有左子树的父节点”
  - **如果他本身就是最后一个元素，则也会遍历到根节点的父节点，返回nullptr **

#### 删除节点

> 原则就是中序遍历不能乱。

- 被删除节点同时有左子树与右子树:。 将其前驱节点的值保存在当前节点，并删除前驱节点
  - 其前驱结点只有一个子树或者没有子树，转化为情况2、3。
- 被删除节点只有左子树或只有右子树：直接用节点的子树替换节点。
- 被删除节点没有子树。 直接删除节点
- **记得考虑前驱节点是不是根节点，如果是的话，把前驱节点的孩子节点赋给root**
- 如果找到了相等的key 1.【寻找要删除的节点】判是否是情况三 如果是则直接赋给del，如果不是，则把它的前驱节点赋给del 2.如果del有子节点（最多也只有一个），把它的子节点和父节点关联（此处要判断，如果父节点是root，则把子节点赋给root，如果不是，就判断是左孩子还是右孩子，赋相应的值。） 3.把del的值传给pnode 4.删除del 。



### 二叉平衡树（AVL）

- 二叉查找树，并且**每个节点** 左子树和右子树高度差最多为1.
- AVL树的查找、插入、删除操作在平均和最坏情况下都是O（logn）
- 概念： 平衡因子BF （左子树高度减右子树高度，范围[ -1,1 ] ),

#### 失衡调整

> 失衡调整是插入与删除操作的基础。
>
> 原则是不影响中序遍历。

- 左旋：左子树插入左孩子
  - 把**最小失衡子树的根节点** 转为该节点右子树的左孩子节点。如果该节点右子树有左节点，则转给该节点的右孩子节点。（原则是不能影响中序遍历）。然后要重新计算最小失衡子树根节点以及它的右孩子节点的高度（整个过程只有这两个改变了，记得+1）。
- 右旋：右子树插入右孩子
  - 把最小失衡子树的根节点 转为该节点左子树的右孩子节点。如果该节点的右孩子节点原来有右子树，则把右子树转成该节点的左子树。 然后重新计算节点高度。
- 先左后右：左子树插入右孩子
  - 先对最小失衡子树的根节点的左孩子节点进行左旋，然后对根节点进行右旋。
- 先右后左： 右子树插入左孩子
  - 先对最小失衡子树的根节点的右孩子节点进行右旋，然后对根节点进行左旋。

#### 插入

- 1、递归寻找合适插入位置，每步递归要计算是否失衡。 2、找到合适位置后新建节点。并重新计算节点高度（记得+1），之后返回该节点。
- 传参要传指针的引用 AVLTreeNode<T>* & ; 因为要修改树的结构。
- ​

#### 删除

- 1、寻找要删除的元素 2、类似BST，如果左右子树都不空，则参考左右子树高度，寻找前驱或者后继替代删除 	（删除替代节点也要递归删除）；否则可以直接删除，然后返回nullptr或者一个子树。


### 二叉堆

- 用数组存储，用数字规律求解。
- 插入 到数组尾，然后自下到上调整（交换）
- 删除 用数组尾的数字代替要删除的数，然后size-- ； 自上到下调整。

### 哈弗曼树

- 概念：路径与路径长度，节点的权，带权路径长度。
- 使用deque作为森林，存储所有节点；使用标准库算法sort对其排序。十分简单



# 算法

- 冒泡 :双重循环，一出现不正常元素 ，就进行交换。
- 简单选择： 双重循环，只交换最小元素。
- 直接插入：最好o(n) ,最差 o(n^2)
- 希尔插入、希尔交换  最好 o(n^(3/2)) ,最差o(n^2)
- 堆排序（二叉堆）:1.构建二叉堆，从第一个非叶子结点开始逆序调整。 2.交换堆顶元素和末尾元素 再调整
  - 每次调整之后，顶上的元素永远是最大的。所以把顶上的元素和末尾元素交换，就把最大的元素拍到末尾了。
  - 最好最坏平均都是 o(nlogn)
- 归并排序：分而治之！
  - 使用迭代的方法分和治，先分再治；递归到first>=last时到达终点。

